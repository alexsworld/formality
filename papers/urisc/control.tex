\chapter{The Control Unit}

\section{Design}
For the computer to work correctly  a number of signals need to be sent to different components at different times.
 Most of these signals are generated by the control unit.
  It implements the instruction fetch and execute sequence, and performs memory accesses for the host.
  It is  a finite state machine 
which uses four input signals to select the next state, and produces fourteen outputs
 (table~\ref{table:control}).

The design of this unit had to wait until the rest of the computer had been designed on a component by component basis.
 I had originally envisaged that the Control Unit would need to know whether the current operand was indexed or not, or if it should be skipped altogether. 
 By  hardwiring these features into the Execution Unit, the Control Unit operates  without knowledge of the current instruction.

It is supplied with the $\overline{halt}$ signal from the Memory Unit, to indicate the validity of the current read access. 
If  reading a memory location is not possible this signal  is  pulled low, and the Control Unit  abandons the current access and enter a halted state.
\begin{table}
\center
\begin{tabular}{||l|ll||}
\hline
direction & signal &  description \\
\hline 
Input 
& $\overline{go}$ &  from the host - execution control\\
 & $\overline{load}$   & load {\bf address} and {\bf data} registers\\
 & l/$\overline{s}$ &  indicates the type of the memory access\\
 & $\overline{halt}$	 & indicates the current read is invalid\\
\hline

Output
  & State 0 & these give the current state of the control unit\\
 & State 1 &   and are all zero on power up\\
 & State 2 &   or after a halt\\
 & State 3 &  \\
 & State 4 &  \\
 & r/$\overline{w}$ & memory access direction\\
 & ms & requests a memory access\\
 & loadD & load {\bf data} register\\
 & loadM & load {\bf address} register\\
 & loadI & load {\bf instruction} register\\
 & loadPCR & load {\bf PCR} register\\
 & incPC & increment the Program Counter\\
 & $\overline{s}$/d & select source or destination operand\\
 & $\overline{OeOP}$  & output  enable current operand\\
 \hline
 \end{tabular}
 \caption{Control Unit Inputs and Outputs}
 \label{table:control}
 \end{table}
 
\section{Implementation}

The Control Unit is implemented as a single 24 pin EPLD. This can be in five operating states:
\begin{itemize}
\item
	stopped
\item
	instruction execution
\item
loading the Data, Address and  Instruction registers from their 
shadows
\item
	performing a read operation for the host
\item
	performing a write operation for the host
\end{itemize}
The read and write operations, and hence also instruction  
execution,  take more than one clock cycle to be completed.
 The actual number of cycles depends upon
the speed of the clock relative to the memory access time.
The Moore Machine within the EPLD  is therefore  designed to contain up to 32 states ---extra wait states  need to be inserted as the clock speed is increased.

 
\subsection{Clock}

The Control Unit, address decoder and Program Counter are all supplied with a common clock. 
The host inputs are  synchronised against this clock to ensure that no signals change so close to its rising edge that  setup times are violated.

A system clock is generated on the board using an
oscillator module. 
The output of this clock is then fed into a multiplexer. The 
multiplexer  selects, under  host control, to use either the on 
board clock or a host generated clock signal. 

\subsection{Difficulties with EPLDS}

There was major confusion over which EPLDS can be 
programmed within the department, to my eventual detriment. It was never clear whether the software to program the devices which 
the department has ---the A+ package---  would actually be able to 
program the fast EP610 devices, or just the slower EP600 ICs. 
Claims that an EP610  was programmed by a previous year's 
student were supported by a salesman at the suppliers who said it was possible.
There were, however, some  rumors that this was not in fact possible with our old
programmer and software.
 Eventually, after I had sent off an order for two  EP610 EPLDS, it was confirmed that the programmer 
would not be able to program the faster devices. 
Fortunately, I was able to change 
my order to EP600 EPLDS. 
These have a maximum cycle time of 45~nS and  a 38~nS setup time, so are neither fast nor  responsive.
This  limits the performance of the computer significantly,
reducing its  maximum possible clock frequency from 40~MHz to 20~MHz.






